{
  "version": 3,
  "sources": ["../../three/examples/jsm/shaders/FilmShader.js", "../../three/examples/jsm/postprocessing/FilmPass.js"],
  "sourcesContent": ["/**\r\n * Film grain & scanlines shader\r\n *\r\n * - ported from HLSL to WebGL / GLSL\r\n * https://web.archive.org/web/20210226214859/http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\r\n *\r\n * Screen Space Static Postprocessor\r\n *\r\n * Produces an analogue noise overlay similar to a film grain / TV static\r\n *\r\n * Original implementation and noise algorithm\r\n * Pat 'Hawthorne' Shearon\r\n *\r\n * Optimized scanlines + noise version with intensity scaling\r\n * Georg 'Leviathan' Steinrohder\r\n *\r\n * This version is provided under a Creative Commons Attribution 3.0 License\r\n * http://creativecommons.org/licenses/by/3.0/\r\n */\r\n\r\nconst FilmShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t'tDiffuse': { value: null },\r\n\t\t'time': { value: 0.0 },\r\n\t\t'nIntensity': { value: 0.5 },\r\n\t\t'sIntensity': { value: 0.05 },\r\n\t\t'sCount': { value: 4096 },\r\n\t\t'grayscale': { value: 1 }\r\n\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = uv;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\r\n\t\t#include <common>\r\n\r\n\t\t// control parameter\r\n\t\tuniform float time;\r\n\r\n\t\tuniform bool grayscale;\r\n\r\n\t\t// noise effect intensity value (0 = no effect, 1 = full effect)\r\n\t\tuniform float nIntensity;\r\n\r\n\t\t// scanlines effect intensity value (0 = no effect, 1 = full effect)\r\n\t\tuniform float sIntensity;\r\n\r\n\t\t// scanlines effect count value (0 = no effect, 4096 = full effect)\r\n\t\tuniform float sCount;\r\n\r\n\t\tuniform sampler2D tDiffuse;\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t// sample the source\r\n\t\t\tvec4 cTextureScreen = texture2D( tDiffuse, vUv );\r\n\r\n\t\t// make some noise\r\n\t\t\tfloat dx = rand( vUv + time );\r\n\r\n\t\t// add noise\r\n\t\t\tvec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );\r\n\r\n\t\t// get us a sine and cosine\r\n\t\t\tvec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\r\n\r\n\t\t// add scanlines\r\n\t\t\tcResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\r\n\r\n\t\t// interpolate between source and result by intensity\r\n\t\t\tcResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\r\n\r\n\t\t// convert to grayscale if desired\r\n\t\t\tif( grayscale ) {\r\n\r\n\t\t\t\tcResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgl_FragColor =  vec4( cResult, cTextureScreen.a );\r\n\r\n\t\t}`,\r\n\r\n};\r\n\r\nexport { FilmShader };\r\n", "import {\r\n\tShaderMaterial,\r\n\tUniformsUtils\r\n} from 'three';\r\nimport { Pass, FullScreenQuad } from './Pass.js';\r\nimport { FilmShader } from '../shaders/FilmShader.js';\r\n\r\nclass FilmPass extends Pass {\r\n\r\n\tconstructor( noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tconst shader = FilmShader;\r\n\r\n\t\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\r\n\r\n\t\tthis.material = new ShaderMaterial( {\r\n\r\n\t\t\tuniforms: this.uniforms,\r\n\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\tfragmentShader: shader.fragmentShader\r\n\r\n\t\t} );\r\n\r\n\t\tif ( grayscale !== undefined )\tthis.uniforms.grayscale.value = grayscale;\r\n\t\tif ( noiseIntensity !== undefined ) this.uniforms.nIntensity.value = noiseIntensity;\r\n\t\tif ( scanlinesIntensity !== undefined ) this.uniforms.sIntensity.value = scanlinesIntensity;\r\n\t\tif ( scanlinesCount !== undefined ) this.uniforms.sCount.value = scanlinesCount;\r\n\r\n\t\tthis.fsQuad = new FullScreenQuad( this.material );\r\n\r\n\t}\r\n\r\n\trender( renderer, writeBuffer, readBuffer, deltaTime /*, maskActive */ ) {\r\n\r\n\t\tthis.uniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\t\tthis.uniforms[ 'time' ].value += deltaTime;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.setRenderTarget( null );\r\n\t\t\tthis.fsQuad.render( renderer );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.setRenderTarget( writeBuffer );\r\n\t\t\tif ( this.clear ) renderer.clear();\r\n\t\t\tthis.fsQuad.render( renderer );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis.material.dispose();\r\n\r\n\t\tthis.fsQuad.dispose();\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { FilmPass };\r\n"],
  "mappings": ";;;;;;;;;;AAoBA,IAAM,aAAa;AAAA,EAElB,UAAU;AAAA,IAET,YAAY,EAAE,OAAO,KAAK;AAAA,IAC1B,QAAQ,EAAE,OAAO,EAAI;AAAA,IACrB,cAAc,EAAE,OAAO,IAAI;AAAA,IAC3B,cAAc,EAAE,OAAO,KAAK;AAAA,IAC5B,UAAU,EAAE,OAAO,KAAK;AAAA,IACxB,aAAa,EAAE,OAAO,EAAE;AAAA,EAEzB;AAAA,EAEA;AAAA;AAAA,IAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWxB;AAAA;AAAA,IAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqD3B;;;AC1FA,IAAM,WAAN,cAAuB,KAAK;AAAA,EAE3B,YAAa,gBAAgB,oBAAoB,gBAAgB,WAAY;AAE5E,UAAM;AAEN,UAAM,SAAS;AAEf,SAAK,WAAW,cAAc,MAAO,OAAO,QAAS;AAErD,SAAK,WAAW,IAAI,eAAgB;AAAA,MAEnC,UAAU,KAAK;AAAA,MACf,cAAc,OAAO;AAAA,MACrB,gBAAgB,OAAO;AAAA,IAExB,CAAE;AAEF,QAAK,cAAc;AAAY,WAAK,SAAS,UAAU,QAAQ;AAC/D,QAAK,mBAAmB;AAAY,WAAK,SAAS,WAAW,QAAQ;AACrE,QAAK,uBAAuB;AAAY,WAAK,SAAS,WAAW,QAAQ;AACzE,QAAK,mBAAmB;AAAY,WAAK,SAAS,OAAO,QAAQ;AAEjE,SAAK,SAAS,IAAI,eAAgB,KAAK,QAAS;AAAA,EAEjD;AAAA,EAEA,OAAQ,UAAU,aAAa,YAAY,WAA8B;AAExE,SAAK,SAAU,UAAW,EAAE,QAAQ,WAAW;AAC/C,SAAK,SAAU,MAAO,EAAE,SAAS;AAEjC,QAAK,KAAK,gBAAiB;AAE1B,eAAS,gBAAiB,IAAK;AAC/B,WAAK,OAAO,OAAQ,QAAS;AAAA,IAE9B,OAAO;AAEN,eAAS,gBAAiB,WAAY;AACtC,UAAK,KAAK;AAAQ,iBAAS,MAAM;AACjC,WAAK,OAAO,OAAQ,QAAS;AAAA,IAE9B;AAAA,EAED;AAAA,EAEA,UAAU;AAET,SAAK,SAAS,QAAQ;AAEtB,SAAK,OAAO,QAAQ;AAAA,EAErB;AAED;",
  "names": []
}
