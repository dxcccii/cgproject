{
  "version": 3,
  "sources": ["../../three/examples/jsm/shaders/ConvolutionShader.js", "../../three/examples/jsm/postprocessing/BloomPass.js"],
  "sourcesContent": ["import {\r\n\tVector2\r\n} from 'three';\r\n\r\n/**\r\n * Convolution shader\r\n * ported from o3d sample to WebGL / GLSL\r\n */\r\n\r\nconst ConvolutionShader = {\r\n\r\n\tdefines: {\r\n\r\n\t\t'KERNEL_SIZE_FLOAT': '25.0',\r\n\t\t'KERNEL_SIZE_INT': '25'\r\n\r\n\t},\r\n\r\n\tuniforms: {\r\n\r\n\t\t'tDiffuse': { value: null },\r\n\t\t'uImageIncrement': { value: new Vector2( 0.001953125, 0.0 ) },\r\n\t\t'cKernel': { value: [] }\r\n\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\tuniform vec2 uImageIncrement;\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\r\n\t\tuniform float cKernel[ KERNEL_SIZE_INT ];\r\n\r\n\t\tuniform sampler2D tDiffuse;\r\n\t\tuniform vec2 uImageIncrement;\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvec2 imageCoord = vUv;\r\n\t\t\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\r\n\r\n\t\t\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\r\n\r\n\t\t\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\r\n\t\t\t\timageCoord += uImageIncrement;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgl_FragColor = sum;\r\n\r\n\t\t}`,\r\n\r\n\tbuildKernel: function ( sigma ) {\r\n\r\n\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\r\n\r\n\t\tconst kMaxKernelSize = 25;\r\n\t\tlet kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\r\n\r\n\t\tif ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;\r\n\r\n\t\tconst halfWidth = ( kernelSize - 1 ) * 0.5;\r\n\r\n\t\tconst values = new Array( kernelSize );\r\n\t\tlet sum = 0.0;\r\n\t\tfor ( let i = 0; i < kernelSize; ++ i ) {\r\n\r\n\t\t\tvalues[ i ] = gauss( i - halfWidth, sigma );\r\n\t\t\tsum += values[ i ];\r\n\r\n\t\t}\r\n\r\n\t\t// normalize the kernel\r\n\r\n\t\tfor ( let i = 0; i < kernelSize; ++ i ) values[ i ] /= sum;\r\n\r\n\t\treturn values;\r\n\r\n\t}\r\n\r\n};\r\n\r\nfunction gauss( x, sigma ) {\r\n\r\n\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\r\n\r\n}\r\n\r\nexport { ConvolutionShader };\r\n", "import {\r\n\tAdditiveBlending,\r\n\tShaderMaterial,\r\n\tUniformsUtils,\r\n\tVector2,\r\n\tWebGLRenderTarget\r\n} from 'three';\r\nimport { Pass, FullScreenQuad } from './Pass.js';\r\nimport { ConvolutionShader } from '../shaders/ConvolutionShader.js';\r\n\r\nclass BloomPass extends Pass {\r\n\r\n\tconstructor( strength = 1, kernelSize = 25, sigma = 4 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\t// render targets\r\n\r\n\t\tthis.renderTargetX = new WebGLRenderTarget(); // will be resized later\r\n\t\tthis.renderTargetX.texture.name = 'BloomPass.x';\r\n\t\tthis.renderTargetY = new WebGLRenderTarget(); // will be resized later\r\n\t\tthis.renderTargetY.texture.name = 'BloomPass.y';\r\n\r\n\t\t// combine material\r\n\r\n\t\tthis.combineUniforms = UniformsUtils.clone( CombineShader.uniforms );\r\n\r\n\t\tthis.combineUniforms[ 'strength' ].value = strength;\r\n\r\n\t\tthis.materialCombine = new ShaderMaterial( {\r\n\r\n\t\t\tuniforms: this.combineUniforms,\r\n\t\t\tvertexShader: CombineShader.vertexShader,\r\n\t\t\tfragmentShader: CombineShader.fragmentShader,\r\n\t\t\tblending: AdditiveBlending,\r\n\t\t\ttransparent: true\r\n\r\n\t\t} );\r\n\r\n\t\t// convolution material\r\n\r\n\t\tconst convolutionShader = ConvolutionShader;\r\n\r\n\t\tthis.convolutionUniforms = UniformsUtils.clone( convolutionShader.uniforms );\r\n\r\n\t\tthis.convolutionUniforms[ 'uImageIncrement' ].value = BloomPass.blurX;\r\n\t\tthis.convolutionUniforms[ 'cKernel' ].value = ConvolutionShader.buildKernel( sigma );\r\n\r\n\t\tthis.materialConvolution = new ShaderMaterial( {\r\n\r\n\t\t\tuniforms: this.convolutionUniforms,\r\n\t\t\tvertexShader: convolutionShader.vertexShader,\r\n\t\t\tfragmentShader: convolutionShader.fragmentShader,\r\n\t\t\tdefines: {\r\n\t\t\t\t'KERNEL_SIZE_FLOAT': kernelSize.toFixed( 1 ),\r\n\t\t\t\t'KERNEL_SIZE_INT': kernelSize.toFixed( 0 )\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tthis.needsSwap = false;\r\n\r\n\t\tthis.fsQuad = new FullScreenQuad( null );\r\n\r\n\t}\r\n\r\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\r\n\r\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\r\n\r\n\t\t// Render quad with blured scene into texture (convolution pass 1)\r\n\r\n\t\tthis.fsQuad.material = this.materialConvolution;\r\n\r\n\t\tthis.convolutionUniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\t\tthis.convolutionUniforms[ 'uImageIncrement' ].value = BloomPass.blurX;\r\n\r\n\t\trenderer.setRenderTarget( this.renderTargetX );\r\n\t\trenderer.clear();\r\n\t\tthis.fsQuad.render( renderer );\r\n\r\n\r\n\t\t// Render quad with blured scene into texture (convolution pass 2)\r\n\r\n\t\tthis.convolutionUniforms[ 'tDiffuse' ].value = this.renderTargetX.texture;\r\n\t\tthis.convolutionUniforms[ 'uImageIncrement' ].value = BloomPass.blurY;\r\n\r\n\t\trenderer.setRenderTarget( this.renderTargetY );\r\n\t\trenderer.clear();\r\n\t\tthis.fsQuad.render( renderer );\r\n\r\n\t\t// Render original scene with superimposed blur to texture\r\n\r\n\t\tthis.fsQuad.material = this.materialCombine;\r\n\r\n\t\tthis.combineUniforms[ 'tDiffuse' ].value = this.renderTargetY.texture;\r\n\r\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\r\n\r\n\t\trenderer.setRenderTarget( readBuffer );\r\n\t\tif ( this.clear ) renderer.clear();\r\n\t\tthis.fsQuad.render( renderer );\r\n\r\n\t}\r\n\r\n\tsetSize( width, height ) {\r\n\r\n\t\tthis.renderTargetX.setSize( width, height );\r\n\t\tthis.renderTargetY.setSize( width, height );\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis.renderTargetX.dispose();\r\n\t\tthis.renderTargetY.dispose();\r\n\r\n\t\tthis.materialCombine.dispose();\r\n\t\tthis.materialConvolution.dispose();\r\n\r\n\t\tthis.fsQuad.dispose();\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst CombineShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t'tDiffuse': { value: null },\r\n\t\t'strength': { value: 1.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = uv;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\r\n\t\tuniform float strength;\r\n\r\n\t\tuniform sampler2D tDiffuse;\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\r\n\t\t\tgl_FragColor = strength * texel;\r\n\r\n\t\t}`\r\n\r\n};\r\n\r\nBloomPass.blurX = new Vector2( 0.001953125, 0.0 );\r\nBloomPass.blurY = new Vector2( 0.0, 0.001953125 );\r\n\r\nexport { BloomPass };\r\n"],
  "mappings": "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",
  "names": []
}
